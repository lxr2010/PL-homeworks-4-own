// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Belt_HashMapString = require("rescript/lib/js/belt_HashMapString.js");

function toString(instrs) {
  var toStringList = function (instr) {
    if (typeof instr === "number") {
      switch (instr) {
        case /* Add */0 :
            return {
                    hd: "Add",
                    tl: /* [] */0
                  };
        case /* Mul */1 :
            return {
                    hd: "Mul",
                    tl: /* [] */0
                  };
        case /* Pop */2 :
            return {
                    hd: "Pop",
                    tl: /* [] */0
                  };
        case /* Swap */3 :
            return {
                    hd: "Swap",
                    tl: /* [] */0
                  };
        case /* Exit */4 :
            return {
                    hd: "Exit",
                    tl: /* [] */0
                  };
        
      }
    } else {
      switch (instr.TAG | 0) {
        case /* Cst */0 :
            return {
                    hd: "Cst(" + instr._0.toString() + ")",
                    tl: /* [] */0
                  };
        case /* Var */1 :
            return {
                    hd: "Var(" + instr._0.toString() + ")",
                    tl: /* [] */0
                  };
        case /* Label */2 :
            return {
                    hd: "Label(" + instr._0 + ")",
                    tl: /* [] */0
                  };
        case /* Call */3 :
            return {
                    hd: "Call(" + instr._0 + "," + instr._1.toString() + ")",
                    tl: /* [] */0
                  };
        case /* Ret */4 :
            return {
                    hd: "Ret(" + instr._0.toString() + ")",
                    tl: /* [] */0
                  };
        case /* Goto */5 :
            return {
                    hd: "Goto(" + instr._0 + ")",
                    tl: /* [] */0
                  };
        case /* IfZero */6 :
            return {
                    hd: "IfZero(" + instr._0 + ")",
                    tl: /* [] */0
                  };
        
      }
    }
  };
  var outputList = Belt_List.concatMany(Belt_Array.map(instrs, toStringList));
  var listTailToString = function (instr_strs) {
    return List.fold_left((function (str, inst) {
                  return str + ";" + inst;
                }), "", instr_strs);
  };
  if (!outputList) {
    return "[]";
  }
  var rest = outputList.tl;
  var inst = outputList.hd;
  if (rest) {
    return "[" + inst + listTailToString(rest) + "]";
  } else {
    return "[" + inst + "]";
  }
}

function size_of_instr(instr) {
  if (typeof instr === "number") {
    switch (instr) {
      case /* Add */0 :
      case /* Mul */1 :
      case /* Pop */2 :
      case /* Swap */3 :
      case /* Exit */4 :
          return 1;
      
    }
  } else {
    switch (instr.TAG | 0) {
      case /* Label */2 :
          return 0;
      case /* Call */3 :
          return 3;
      default:
        return 2;
    }
  }
}

function encode(instrs) {
  var position = 0;
  var label_map = Belt_HashMapString.make(10);
  for(var cur = 0 ,cur_finish = instrs.length; cur < cur_finish; ++cur){
    var l = Caml_array.get(instrs, cur);
    if (typeof l === "number" || l.TAG !== /* Label */2) {
      position = position + size_of_instr(l) | 0;
    } else {
      Belt_HashMapString.set(label_map, l._0, position);
    }
  }
  var int_code = Belt_Array.make(position, 0);
  position = 0;
  for(var cur$1 = 0 ,cur_finish$1 = instrs.length; cur$1 < cur_finish$1; ++cur$1){
    var i = Caml_array.get(instrs, cur$1);
    if (typeof i === "number") {
      switch (i) {
        case /* Add */0 :
            Caml_array.set(int_code, position, 1);
            break;
        case /* Mul */1 :
            Caml_array.set(int_code, position, 2);
            break;
        case /* Pop */2 :
            Caml_array.set(int_code, position, 4);
            break;
        case /* Swap */3 :
            Caml_array.set(int_code, position, 5);
            break;
        case /* Exit */4 :
            Caml_array.set(int_code, position, 10);
            break;
        
      }
    } else {
      switch (i.TAG | 0) {
        case /* Cst */0 :
            Caml_array.set(int_code, position, 0);
            Caml_array.set(int_code, position + 1 | 0, i._0);
            break;
        case /* Var */1 :
            Caml_array.set(int_code, position, 3);
            Caml_array.set(int_code, position + 1 | 0, i._0);
            break;
        case /* Label */2 :
            break;
        case /* Call */3 :
            var addr = Belt_HashMapString.get(label_map, i._0);
            var label_addr;
            if (addr !== undefined) {
              label_addr = addr;
            } else {
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "Demo.res",
                      86,
                      15
                    ],
                    Error: new Error()
                  };
            }
            Caml_array.set(int_code, position, 6);
            Caml_array.set(int_code, position + 1 | 0, label_addr);
            Caml_array.set(int_code, position + 2 | 0, i._1);
            break;
        case /* Ret */4 :
            Caml_array.set(int_code, position, 7);
            Caml_array.set(int_code, position + 1 | 0, i._0);
            break;
        case /* Goto */5 :
            var addr$1 = Belt_HashMapString.get(label_map, i._0);
            var label_addr$1;
            if (addr$1 !== undefined) {
              label_addr$1 = addr$1;
            } else {
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "Demo.res",
                      107,
                      15
                    ],
                    Error: new Error()
                  };
            }
            Caml_array.set(int_code, position, 9);
            Caml_array.set(int_code, position + 1 | 0, label_addr$1);
            break;
        case /* IfZero */6 :
            var addr$2 = Belt_HashMapString.get(label_map, i._0);
            var label_addr$2;
            if (addr$2 !== undefined) {
              label_addr$2 = addr$2;
            } else {
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "Demo.res",
                      99,
                      15
                    ],
                    Error: new Error()
                  };
            }
            Caml_array.set(int_code, position, 8);
            Caml_array.set(int_code, position + 1 | 0, label_addr$2);
            break;
        
      }
    }
    position = position + size_of_instr(Caml_array.get(instrs, cur$1)) | 0;
  }
  return int_code;
}

var cst_test = [
  {
    TAG: /* Cst */0,
    _0: 2
  },
  /* Exit */4
];

var call_test = [
  {
    TAG: /* Call */3,
    _0: "func",
    _1: 0
  },
  /* Exit */4,
  {
    TAG: /* Label */2,
    _0: "func"
  },
  {
    TAG: /* Cst */0,
    _0: 15
  }
];

var call_test2 = [
  {
    TAG: /* Cst */0,
    _0: 2
  },
  {
    TAG: /* Cst */0,
    _0: 3
  },
  {
    TAG: /* Cst */0,
    _0: 5
  },
  {
    TAG: /* Call */3,
    _0: "addmul",
    _1: 3
  },
  /* Exit */4,
  {
    TAG: /* Label */2,
    _0: "addmul"
  },
  {
    TAG: /* Var */1,
    _0: 2
  },
  {
    TAG: /* Var */1,
    _0: 2
  },
  /* Add */0,
  {
    TAG: /* Var */1,
    _0: 1
  },
  /* Mul */1,
  {
    TAG: /* Ret */4,
    _0: 3
  }
];

function test(instrs) {
  console.log(toString(instrs));
  console.log(encode(instrs));
}

var StackMachine = {
  toString: toString,
  size_of_instr: size_of_instr,
  encode: encode,
  cst_test: cst_test,
  call_test: call_test,
  call_test2: call_test2,
  test: test
};

test(call_test2);

exports.StackMachine = StackMachine;
/*  Not a pure module */
